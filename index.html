<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<title>Dojo Nutrition</title>
<script src="https://cdn.tailwindcss.com"></script>
<link rel="stylesheet" href="dojo.css">

<style>
body { font-family: sans-serif; }
</style>
</head>

<body class="dojo-bg">

<div class="paper-stone max-w-md mx-auto p-6 rounded-xl shadow mt-8">

<h1 class="hand-font text-3xl burned-text text-center mb-6">Nutrition Search</h1>

<!-- Search -->
<div style="position:relative;">
  <div id="ghostSuggestion" aria-hidden="true" style="position:absolute;left:0;top:0;padding:12px 12px;font-size:18px;color:#9ca3af;pointer-events:none;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:100%;"></div>
  <input id="searchInput" class="fluid-input w-full rounded p-3 text-lg" style="position:relative; background:transparent;"
  placeholder="Search ingredient (e.g., salmon)..."
  autocomplete="off">
</div>

<div id="results" class="bg-white text-black rounded mt-1 hidden results-list max-h-60 overflow-y-auto shadow border border-gray-200" style="position:absolute; z-index:20; width: calc(100% - 3rem);"></div>

<div id="errorMsg" class="text-red-600 mt-2 hidden"></div>

<!-- Amount -->
<div class="flex gap-3 mt-6">
<input id="amount" type="number" value="100"
class="fluid-input rounded p-3 w-1/2" />

<select id="unit" class="fluid-input rounded p-3 w-1/2">
<option value="g">grams</option>
<option value="oz">ounces</option>
<option value="lb">pounds</option>
<option value="cup">cup</option>
<option value="tbsp">tablespoon</option>
<option value="tsp">teaspoon</option>
</select>
</div>

<!-- Output -->
<div id="nutrition" class="mt-8 text-lg"></div>
</div>

<div style="text-align:center;margin-top:20px;">
  <a href="index.html" style="color: white;">Search</a> |
  <a href="pantry.html" style="color: white;">Pantry</a> |
  <a href="dish.html" style="color: white;">Dish</a> |
  <a href="profile.html" style="color: white;">Profile</a> |
  <a href="settings.html" style="color: white;">Settings</a>
</div>

<script src="logic.js"></script>
<script>
// Force refresh when returning via back/forward cache so we always show the latest page
window.addEventListener("pageshow", (event) => {
  const nav = performance.getEntriesByType("navigation")[0];
  if ((event.persisted || nav?.type === "back_forward") && !sessionStorage.getItem("dojo_index_refreshed")) {
    sessionStorage.setItem("dojo_index_refreshed", "1");
    window.location.reload();
  }
});

// DOM
const input = document.getElementById("searchInput");
const results = document.getElementById("results");
const amount = document.getElementById("amount");
const unit = document.getElementById("unit");
const out = document.getElementById("nutrition");
const errorMsg = document.getElementById("errorMsg");
const ghost = document.getElementById("ghostSuggestion");

let selectedFood = null;
let selectedNutrition = null;
let searchTimer = null;
// Predictive search on input
input.addEventListener("input", () => {
  const query = input.value.trim();
  if (!query || query.length < 3) {
    results.classList.add("hidden");
    results.innerHTML = "";
    if (ghost) ghost.textContent = "";
    return;
  }

  if (searchTimer) clearTimeout(searchTimer);
  searchTimer = setTimeout(() => typeahead(query), 200);
});

async function typeahead(query){
  try {
    const foods = await searchFoods(query, 6);
    if (!foods.length) {
      results.classList.add("hidden");
      results.innerHTML = "";
      if (ghost) ghost.textContent = "";
      return;
    }

    results.innerHTML = foods.map((f, idx) => `
      <div class="p-2 hover:bg-gray-200 cursor-pointer" data-idx="${idx}">
        ${f.name}
      </div>
    `).join("");
    results.classList.remove("hidden");

    // Inline ghost suggestion uses the first result completion
    const first = foods[0];
    if (ghost && first?.name) {
      const lowerQ = query.toLowerCase();
      const lowerName = first.name.toLowerCase();
      if (lowerName.startsWith(lowerQ)) {
        ghost.textContent = query + first.name.slice(query.length);
      } else {
        ghost.textContent = first.name;
      }
    }

    Array.from(results.children).forEach((child, idx) => {
      child.addEventListener("click", async () => {
        try {
          const fresh = await fetchNutrition(foods[idx].name);
          selectFood(foods[idx].name, fresh || foods[idx]);
        } catch {
          selectFood(foods[idx].name, foods[idx]);
        }
      });
    });
  } catch (e) {
    // silent for typeahead
  }
}

// Clear error
function clearError() {
  errorMsg.classList.add("hidden");
  errorMsg.textContent = "";
}

// Show error
function showError(msg) {
  errorMsg.classList.remove("hidden");
  errorMsg.textContent = msg;
}

// Search on Enter key
input.addEventListener("keydown", async (e) => {
  if(e.key === "Enter"){
    const query = input.value.trim();
    if(!query) return;
    
    clearError();
    results.innerHTML = "<div class='p-2'>Searching...</div>";
    results.classList.remove("hidden");
    
    try {
      const nutrition = await fetchNutrition(query);
      if (ghost) ghost.textContent = "";

      if(!nutrition) {
        showError("No results found. Try a different ingredient.");
        results.classList.add("hidden");
        return;
      }

      selectFood(nutrition.name, nutrition);

    } catch(err) {
      console.error("Search error:", err);
      showError("Search failed. Try another term.");
      results.classList.add("hidden");
    }
  }
});

function selectFood(name, nutrition){
  selectedFood = name;
  selectedNutrition = nutrition;
  input.value = name;
  results.classList.add("hidden");
  clearError();
  render();
}

// Compute and display
function render(){
  if(!selectedNutrition) return;
  
  try {
    const grams = toGrams(Number(amount.value), unit.value);
    const scaled = scaleNutrition(selectedNutrition, grams);
    
    if(!scaled) {
      showError("Unable to calculate nutrition.");
      return;
    }
    
    out.innerHTML = `
    <div class="bg-white text-black p-4 rounded">
    <p><b>${selectedFood}</b></p>
    <p>Calories: ${scaled.calories.toFixed(1)}</p>
    <p>Protein: ${scaled.protein_g.toFixed(1)} g</p>
    <p>Carbs: ${scaled.carbohydrates_total_g.toFixed(1)} g</p>
    <p>Fat: ${scaled.fat_total_g.toFixed(1)} g</p>
    </div>`;
    
  } catch(err) {
    console.error("Render error:", err);
    showError("Error calculating nutrition values.");
  }
}

// Update on change
amount.oninput = render;
unit.onchange = render;
</script>

</body>
</html>
