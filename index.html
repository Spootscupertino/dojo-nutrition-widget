<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<title>Dojo Nutrition</title>
<script src="https://cdn.tailwindcss.com"></script>
<link rel="stylesheet" href="dojo.css">

<script>
// Lightweight cache-bust so back/forward always lands on the latest build of index.html
const APP_VERSION = "2025-12-07-1";
const params = new URLSearchParams(window.location.search);
if (params.get("v") !== APP_VERSION) {
  params.set("v", APP_VERSION);
  const url = `${window.location.pathname}?${params.toString()}`;
  window.location.replace(url);
}
</script>

<style>
body { font-family: sans-serif; }
</style>
</head>

<body class="dojo-bg">

<div class="paper-stone max-w-md mx-auto p-6 rounded-xl shadow mt-8">

<h1 class="hand-font text-3xl burned-text text-center mb-6">Nutrition Search</h1>

<!-- Search -->
<div style="position:relative;">
  <div id="ghostSuggestion" aria-hidden="true" style="position:absolute;left:0;top:0;padding:12px 12px;font-size:18px;color:#9ca3af;pointer-events:none;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:100%;"></div>
  <input id="searchInput" class="fluid-input w-full rounded p-3 text-lg" style="position:relative; background:transparent;"
  placeholder="Search ingredient (e.g., salmon)..."
  autocomplete="off">
</div>

<div id="results" class="bg-white text-black rounded mt-1 hidden results-list max-h-60 overflow-y-auto shadow border border-gray-200" style="position:absolute; z-index:20; width: calc(100% - 3rem);"></div>

<div id="errorMsg" class="text-red-600 mt-2 hidden"></div>

<!-- Amount -->
<div class="flex gap-3 mt-6">
<input id="amount" type="number" value="100"
class="fluid-input rounded p-3 w-1/2" />

<select id="unit" class="fluid-input rounded p-3 w-1/2">
<option value="g">grams</option>
<option value="oz">ounces</option>
<option value="lb">pounds</option>
<option value="cup">cup</option>
<option value="tbsp">tablespoon</option>
<option value="tsp">teaspoon</option>
</select>
</div>

<!-- Output -->
<div id="nutrition" class="mt-8 text-lg"></div>
<div id="actions" class="mt-4 space-x-2 hidden">
  <button id="addPantryBtn" class="bg-white text-black px-3 py-2 rounded shadow">Add to Pantry</button>
  <button id="addDishBtn" class="bg-white text-black px-3 py-2 rounded shadow">Add to Dish</button>
  <div id="dishPicker" class="mt-2 hidden">
    <label class="text-white text-sm">Choose dish</label>
    <select id="dishSelect" class="w-full p-2 rounded text-black max-h-40 overflow-y-auto">
      <option value="">Select a dish...</option>
    </select>
  </div>
</div>
</div>

<div style="text-align:center;margin-top:20px;">
  <a href="index.html" style="color: white;">Search</a> |
  <a href="pantry.html" style="color: white;">Pantry</a> |
  <a href="dish.html" style="color: white;">Dish</a> |
  <a href="profile.html" style="color: white;">Profile</a> |
  <a href="settings.html" style="color: white;">Settings</a>
</div>

<script src="logic.js"></script>
<script>
// Force refresh when returning via back/forward cache so we always show the latest page
window.addEventListener("pageshow", (event) => {
  const nav = performance.getEntriesByType("navigation")[0];
  if ((event.persisted || nav?.type === "back_forward") && !sessionStorage.getItem("dojo_index_refreshed")) {
    sessionStorage.setItem("dojo_index_refreshed", "1");
    window.location.reload();
  }
});

// DOM
const input = document.getElementById("searchInput");
const results = document.getElementById("results");
const amount = document.getElementById("amount");
const unit = document.getElementById("unit");
const out = document.getElementById("nutrition");
const errorMsg = document.getElementById("errorMsg");
const ghost = document.getElementById("ghostSuggestion");
const actions = document.getElementById("actions");
const addPantryBtn = document.getElementById("addPantryBtn");
const addDishBtn = document.getElementById("addDishBtn");
const dishPicker = document.getElementById("dishPicker");
const dishSelect = document.getElementById("dishSelect");

let selectedFood = null;
let selectedNutrition = null;
let searchTimer = null;
// Predictive search on input
input.addEventListener("input", () => {
  const query = input.value.trim();
  if (!query || query.length < 3) {
    results.classList.add("hidden");
    results.innerHTML = "";
    if (ghost) ghost.textContent = "";
    return;
  }

  if (searchTimer) clearTimeout(searchTimer);
  searchTimer = setTimeout(() => typeahead(query), 200);
});

async function typeahead(query){
  try {
    const foods = await searchFoods(query, 6);
    if (!foods.length) {
      results.classList.add("hidden");
      results.innerHTML = "";
      if (ghost) ghost.textContent = "";
      return;
    }

    results.innerHTML = foods.map((f, idx) => `
      <div class="p-2 hover:bg-gray-200 cursor-pointer" data-idx="${idx}">
        ${f.name}
      </div>
    `).join("");
    results.classList.remove("hidden");

    // Inline ghost suggestion uses the first result completion
    const first = foods[0];
    if (ghost && first?.name) {
      const lowerQ = query.toLowerCase();
      const lowerName = first.name.toLowerCase();
      if (lowerName.startsWith(lowerQ)) {
        ghost.textContent = query + first.name.slice(query.length);
      } else {
        ghost.textContent = first.name;
      }
    }

    Array.from(results.children).forEach((child, idx) => {
      child.addEventListener("click", async () => {
        try {
          const fresh = await fetchNutrition(foods[idx].name);
          selectFood(foods[idx].name, fresh || foods[idx]);
        } catch {
          selectFood(foods[idx].name, foods[idx]);
        }
      });
    });
  } catch (e) {
    // silent for typeahead
  }
}

// Clear error
function clearError() {
  errorMsg.classList.add("hidden");
  errorMsg.textContent = "";
}

// Show error
function showError(msg) {
  errorMsg.classList.remove("hidden");
  errorMsg.textContent = msg;
}

// Search on Enter key
input.addEventListener("keydown", async (e) => {
  if(e.key === "Enter"){
    const query = input.value.trim();
    if(!query) return;
    
    clearError();
    results.innerHTML = "<div class='p-2'>Searching...</div>";
    results.classList.remove("hidden");
    
    try {
      const nutrition = await fetchNutrition(query);
      if (ghost) ghost.textContent = "";

      if(!nutrition) {
        showError("No results found. Try a different ingredient.");
        results.classList.add("hidden");
        return;
      }

      selectFood(nutrition.name, nutrition);

    } catch(err) {
      console.error("Search error:", err);
      showError("Search failed. Try another term.");
      results.classList.add("hidden");
    }
  }
});

function selectFood(name, nutrition){
  selectedFood = name;
  selectedNutrition = nutrition;
  input.value = name;
  results.classList.add("hidden");
  clearError();
  render();
}

// Pantry/Dish storage helpers
function getPantry() {
  const stored = localStorage.getItem("dojo_pantry");
  return stored ? JSON.parse(stored) : [];
}
function savePantry(list) {
  localStorage.setItem("dojo_pantry", JSON.stringify(list));
}
function getDishes() {
  const stored = localStorage.getItem("dojo_dishes");
  if (!stored) return [];
  try { return JSON.parse(stored); } catch { return []; }
}
function saveDishes(list) {
  localStorage.setItem("dojo_dishes", JSON.stringify(list));
}

function refreshDishDropdown() {
  if (!dishSelect || !dishPicker) return;
  const dishes = getDishes();
  if (!dishes.length) {
    dishPicker.classList.add("hidden");
    dishSelect.innerHTML = `<option value="">No dishes yet</option>`;
    return;
  }
  dishPicker.classList.remove("hidden");
  const options = ["<option value=''>Select a dish...</option>",
    ...dishes.map(d => `<option value="${d.id}">${d.name || d.id}</option>`)];
  dishSelect.innerHTML = options.join("");
}

function addToPantry() {
  if (!selectedFood || !selectedNutrition) return;
  const amt = amount.value?.trim() || "1";
  const u = unit.value || "g";
  const list = getPantry();
  list.push({ id: Date.now().toString(), name: selectedFood, amount: amt, unit: u });
  savePantry(list);
  showError(`${selectedFood} added to pantry`);
  errorMsg.style.color = "#10b981"; // green
}

function addToDish() {
  if (!selectedFood || !selectedNutrition) return;
  const dishes = getDishes();
  if (!dishes.length) {
    showError("Create a dish first on the Dish page.");
    errorMsg.style.color = "#f87171"; // red
    return;
  }

  const targetId = dishSelect?.value;
  const target = dishes.find(d => d.id === targetId) || null;
  if (!target) {
    showError("Pick a dish from the dropdown.");
    errorMsg.style.color = "#f87171";
    return;
  }

  const amt = amount.value?.trim() || "1";
  const u = unit.value || "g";

  target.ingredients = target.ingredients || [];
  target.ingredients.push({ name: selectedFood, amount: amt, unit: u });
  saveDishes(dishes.map(d => d.id === target.id ? target : d));
  showError(`${selectedFood} added to ${target.name || "dish"}`);
  errorMsg.style.color = "#10b981"; // green
}

// Compute and display
function render(){
  if(!selectedNutrition) return;
  
  try {
    const grams = toGrams(Number(amount.value), unit.value);
    const scaled = scaleNutrition(selectedNutrition, grams);
    
    if(!scaled) {
      showError("Unable to calculate nutrition.");
      return;
    }
    
    out.innerHTML = `
    <div class="bg-white text-black p-4 rounded">
    <p><b>${selectedFood}</b></p>
    <p>Calories: ${scaled.calories.toFixed(1)}</p>
    <p>Protein: ${scaled.protein_g.toFixed(1)} g</p>
    <p>Carbs: ${scaled.carbohydrates_total_g.toFixed(1)} g</p>
    <p>Fat: ${scaled.fat_total_g.toFixed(1)} g</p>
    </div>`;
    if (actions) actions.classList.remove("hidden");
    refreshDishDropdown();
    
  } catch(err) {
    console.error("Render error:", err);
    showError("Error calculating nutrition values.");
  }
}

// Update on change
amount.oninput = render;
unit.onchange = render;

if (addPantryBtn) addPantryBtn.addEventListener("click", addToPantry);
if (addDishBtn) addDishBtn.addEventListener("click", addToDish);
if (dishSelect) dishSelect.addEventListener("change", clearError);
</script>

</body>
</html>
